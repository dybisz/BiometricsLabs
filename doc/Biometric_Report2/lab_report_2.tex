%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 3.1 (25/3/14)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Linux and Unix Users Group at Virginia Tech Wiki 
% (https://vtluug.org/wiki/Example_LaTeX_chem_lab_report)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Modified by:
% Bartlomiej Dybisz
% Warsaw university of Technology
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{amsmath} % Required for some math elements 
\usepackage{url} % for bibliograpy links
\usepackage{float} % To force image to stand still
\usepackage[export]{adjustbox}
\usepackage[usenames, dvipsnames]{color} % to color some important remarks
\usepackage{caption}
\usepackage{wrapfig}
\usepackage{subcaption}

\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}}


\urlstyle{same}  % (for bibliography links
\setlength\parindent{0pt} % Removes all indentation from paragraphs
%\usepackage{array}

\newenvironment{conditions}
  {\par\vspace{\abovedisplayskip}\noindent\begin{tabular}{>{$}l<{$} @{${}\equiv{}$} l}}
  {\end{tabular}\par\vspace{\belowdisplayskip}}
  
 \usepackage{amsfonts} 
\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Analysis and Processing of Biometric Images \\ Laboratory 3} % Title

\author{Bartlomiej \textsc{Dybisz}} % Author name

\date{\today} % Date for the report

\begin{document}

\maketitle % Insert the title, author and date

\begin{center}
\begin{tabular}{l r}
Date Performed: & October 31 , 2015 \\ % Date the experiment was performed
Instructor: & mgr Piotr Panasiuk % Instructor/supervisor
\end{tabular}
\end{center}

% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Objectives}

% If you have more than one objective, uncomment the below:
\begin{description}
\item[Convolution Filters] \hfill \\
To learn mathematics behind convolution filters in order to gain some intuition about them.
\item[High Pass Filter] \hfill \\
To learn how High Pass Filter works and how to implement it using Java.
\item[Low Pass Filter] \hfill \\
To learn how Low Pass Filter works and how to implement it using Java.
\item[Gaussian Filter] \hfill \\
To learn how Gaussian Filter works and how to implement it using Java. 
\item[Sobel Filter] \hfill \\
To learn how Sobel Filter works and how to implement it using Java.
\item[Erosion and Dilation] \hfill \\
To learn how Erosion and Dilation works. Although they were not implemented during laboratories, I will present straight forward implementation using Java. 
\item[Region Filling (Conditional Dilation)] \hfill \\
To learn how Conditional Dilation algorithm works. Region filling is another problem, which has been just mentioned during laboratories. I have decided to expand this report by introducing one of possible algorithm and its implementation in Java.
\item[Region Extraction] \hfill \\
To propose a way to extract a pupil, along with its diameter/radius and center, from an default input image.
This part has been left as a homework. It involves custom solution of the problem.
\end{description}

\subsection{Definitions}
\label{definitions}
\textcolor{red}{Remark:} throughout this report I will assume that each of red, green, blue channels of a pixel can take values from $0$ to $1$. It is imposed by JavaFX 8 - technology used to implement algorithms.

\begin{description}

%
% CONVOLUTION DEFINITION
%
\item[Convolution]
A convolution is an integral that expresses the amount of overlap of one function g as it is shifted over another function f. It therefore "blends" one function with another  \cite{convolution_wolphram}. 

In other words, convolution gives the area overlap between the two functions as a function of the amount that one of the original functions is translated \cite{convolution_wiki}.

Formally, for functions $f(x)$ and $g(x)$ of a continuous variable x, convolution is defined as:
\begin{equation} \label{conv_one_var_cont}
f(x) * g(x) = \int_{-\infty}^{\infty} f(\tau) \cdot g(x - \tau) d\tau
\end{equation}
, where $*$ means convolution operation, $\cdot$ represents common multiplication and $\tau$ is a "shifting variable".

Equation \ref{conv_one_var_cont} can be easily transformed to discrete form as follows:
\begin{equation} \label{conv_one_var_disc}
f[x] * g[x] = \sum_{k=-\infty}^{\infty} f[k] \cdot g[x-k]
\end{equation}
This form will be of particular interest for us, since it can be (more or less) directly applied to an image as showed in the next subsection.

%
% Convolution Filters
%
\item[Convolution Filters]
As mentioned, one can ad hoc transform equation \ref{conv_one_var_disc} into two variable case:
\begin{equation} \label{two_var_conv_one_var_disc}
f[x,y] * g[x,y] =\sum_{n_{1}=-\infty}^{\infty} \sum_{n_{2}=-\infty}^{\infty} f[n_{1}, n_{2}] \cdot g[x-n_{1}, y - n_{2}]
\end{equation}
, but for our purposes (as explained in a moment) we will use a slightly modified version of equation \ref{two_var_conv_one_var_disc}, namely:
\begin{equation} \label{final_two_var_conv_one_var_disc}
f[x,y] * g[x,y] = d \cdot (\sum_{n_{1}=k_{1}}^{k_{2}} \sum_{n_{2}=k_{3}}^{k_{4}} f[n_{1}, n_{2}] \cdot g[x+n_{1}, y + n_{2}])
\end{equation}
,where:
\begin{conditions} 
  d \in \mathbb{R} & scaling variable\\
  n_{1}, n_{2} \in \mathbb{N}& auxiliary shifting variables\\
  k_{1}, k_{2}, k_{3}, k_{4} \in \mathbb{N}& size restriction to convolution matrix (kernel)\\
 (x,y) \in \mathbb{N}^{2}     &  pixel of interest's position on an image in XY coordinates \\   
 f[x,y] : \mathbb{N}^{2} \rightarrow \mathbb{N} &  convolution matrix (kernel) \\
 g[x,y] : \mathbb{N}^{2} \rightarrow \mathbb{N} & an image as a matrix of pixels values
\end{conditions}

Equation \ref{two_var_conv_one_var_disc} has been changed due to obsolete $g[x-k]$ notation of equation \ref{conv_one_var_disc}. In this way we can omit left-right flipping when calculating consecutive pixels.

In addition, we restrict $g[x,y]$ by $k$'s variables, because we want our convolution matrix to be finite. 
In this case we can think of $f[x,y]$ as a frame, which we move over some pixel $(x,y)$ of an image $g[x,y]$. Then by applying equation \ref{final_two_var_conv_one_var_disc} we sum all values of $g$ over
$ \langle x + k_1; x+ k_2 \rangle \cup \langle y + k_3 ; y + k_4 \rangle$ interval multiplied by appropriate values of $f$.

What is more variable $d$ is a constant useful in computer implementation. I presume, that its main aim is to force kernel matrix values to stay in form of natural numbers.

As an example let us assume that:
\begin{conditions} 
  g[x,y] : \langle 1; 5 \rangle \cup \langle 1 ; 7 \rangle \rightarrow \mathbb{N} & some very small image\\
  f[x,y] : \langle -1; 1 \rangle \cup \langle -1 ; 1 \rangle \rightarrow \mathbb{N} & kernel matrix \\
\end{conditions}

In such a case we can present both of them in form of matrices of some natural values. Let us assume that figure \ref{fig:example_repr} defines $f[x,y]$ and $g[x,y]$ in terms of matrices. Value of $d$ will be 1.
\begin{figure}[H]
\centering
\begin{subfigure}{.4\textwidth}
  \centering
  \includegraphics[width=0.95\linewidth]{_Figures/example_11.jpg}
  \caption{}
  \label{fig:example_repr}
\end{subfigure}%
\begin{subfigure}{.4\textwidth}
  \centering
  \includegraphics[width=0.95\linewidth]{_Figures/example_12.jpg}
  \caption{}
  \label{fig:example_43}
\end{subfigure}%
\caption{}
\label{fig:results_tresh}
\end{figure}

Now we want to apply convolution for let us say pixel $(4,3)$. Figure \ref{fig:example_43} represents region of interest. Equation \ref{final_two_var_conv_one_var_disc} for this case takes following form:
\begin{equation} 
\begin{split}
f[4,3] * g[4,3] =\sum_{n_{1}=-1}^{1} \sum_{n_{2}=-1}^{1} f[n_{1}, n_{2}] \cdot g[4+n_{1}, 3 + n_{2}] \\
= f[-1, -1] \cdot g[3, 2] + f[-1, 0] \cdot g[3, 3] + f[-1, 1] \cdot g[3, 4] \\
+ f[0, -1] \cdot g[3, 2] + f[0, 0] \cdot g[3, 3] + f[0, 1] \cdot g[0, 4] \\
+ f[1, -1] \cdot g[3, 2] + f[1, 0] \cdot g[3, 3] + f[1, 1] \cdot g[0, 4] \\
= 3 * 5 + 1 * 1 + 0 * 3 \\
+ 6 * 8 + 2 * 4 + 5 * 2 \\
+ 3 * 9 + 7 * 8 + 8 * 5 \\
= 205
\end{split}
\end{equation}

In this way pixel of output image, positioned at $(4,3)$ will have value $205$. When we apply convolution to all pixels in $g$ we will get an output (filtered) image.

\begin{figure}
\noindent
\begin{minipage}{0.3\textwidth}% adapt widths of minipages to your needs
	\includegraphics[width=\linewidth]{_Figures/conv_filter_border.jpg} 
	\caption{}
	\label{fig:caution}
\end{minipage}%
\hfill%
\begin{minipage}{0.6\textwidth}\raggedleft
\textcolor{red}{Caution:} Border cases i.e. cases when there is no corresponding $g[x,y]$ value for some value of $f[x,y]$ (see figure \ref{fig:caution} for reference), will be treated as special ones. In such a case pixel of interest will keep its value from $g$ function.
\end{minipage}
\end{figure}

\textcolor{red}{Remark:} If not stated otherwise, for the rest of the paper we will use only $3 \times 3$ kernel matrices, hence $k_1 = k_3 = -1$ and $k_2 = k_4 = 1$ and we will apply it to each RGB channel separately. 

%
% HIG PASS FILTER DEFINITION
%
\item[High Pass Filter]
A high pass filter tends to retain the high frequency information within an image while reducing the low frequency information. The kernel of the high pass filter is designed to increase the brightness of the center pixel relative to neighbouring pixels. The kernel array usually contains a single positive value at its center, which is completely surrounded by negative values \cite{high_pass_def}. 

During laboratories we used following kernel:
\[
\begin{pmatrix}
  -1 & -1 & -1 \\
  -1 & 9 & -1 \\
  -1 & -1 & -1  \\
 \end{pmatrix}
 \]
with coefficient $d = \frac{1}{9}$ (see equation \ref{final_two_var_conv_one_var_disc} and previous subsection for a reference). 

%
% LOW PASS FILTER DEFINITION
%
\item[Low Pass Filter]
A low pass filter is the basis for most smoothing methods. An image is smoothed by decreasing the disparity between pixel values by averaging nearby pixels. Using a low pass filter tends to retain the low frequency information within an image while reducing the high frequency information \cite{high_pass_def}.

During laboratories we used following kernel:
\[
\begin{pmatrix}
  1 & 1 & 1 \\
  1 & 1 & 1 \\
  1 & 1 & 1  \\
 \end{pmatrix}
 \]
with coefficient $d = \frac{1}{9}$ (see equation \ref{final_two_var_conv_one_var_disc} and "Convolution Filters" subsection for a reference). 

%
% GAUSSIAN FILTER DEFINITION
% 
\item[Gaussian Filter] Type of image-blurring filter that uses a Gaussian function (which also expresses the normal distribution in statistics) for calculating the transformation to apply to each pixel in the image \cite{gaussian_blur}.

\begin{figure}[H]
\hskip 2.5em
\begin{minipage}{0.6\textwidth}\raggedright
The original pixel's value receives the heaviest weight (having the highest Gaussian value) and neighbouring pixels receive smaller weights as their distance to the original pixel increases. This results in a blur that preserves boundaries and edges better than other, more uniform blurring filters \cite{gaussian_blur}.
\end{minipage}
\begin{minipage}{0.3\textwidth}% adapt widths of minipages to your needs
	\includegraphics[width=\linewidth]{_Figures/gaussian.png} 
	\label{fig:caution}
\end{minipage}%
\hfill%
\end{figure}

During laboratories we used following kernel:
\[
\begin{pmatrix}
  1 & 4 & 1 \\
  4 & 16 & 4 \\
  1 & 4 & 1  \\
 \end{pmatrix}
 \]
with coefficient $d = \frac{1}{36}$ (see equation \ref{final_two_var_conv_one_var_disc} and "Convolution Filters" subsection for a reference). 

\item[Sobel Filter]
Performs a 2D spatial gradient measurement on an image and so emphasizes regions of high spatial frequency that correspond to edges \cite{sobel_bib1}.

Let us define $3 \times 3$ neighbourhood of pixel of interest $px$ as :
\[
N = 
\begin{pmatrix}
  p0 & p1 & p2 \\
  p7 & px & p3 \\
  p6 & p5 & p4
\end{pmatrix}
\]

To approximate appropriate derivatives on x ($G_x$) and y ($G_y$), we use following formulas:
\[
G_x =
\begin{pmatrix}
  -1 & -2 & -1 \\
   0 & 0 & 0 \\
   1 & 2 & 1
\end{pmatrix}
\times
N
\hskip 2.5em
G_y =
\begin{pmatrix}
  -1 & 0 & 1 \\
   -2 & 0 & 2 \\
   -1 & 0 & 1
\end{pmatrix}
\times
N
\]
, where $\times$ is an operation of matrix multiplication. What follows, values of each gradient can be directly calculated from neighbourhood pixels using following equations:
\[
\begin{split}
G_x = (p2 + 2 \cdot p3 + p4) - (p0 + 2 \cdot p7 + p6) \\
G_y = (p6 + 2 \cdot p5 + p4) - (p0 + 2 \cdot p1 + p2)
\end{split}
\]
Now output pixel value ($px_{out}$), based on gradient, can be calculated as:
\[
px_{out} = \sqrt{G_x^2 + G_y^2}
\]

\pagebreak

\item[Blur Filter]
Due to the demands of the task of pupil extraction, I needed some tool to blur an image to a higher degree than $3 \times 3$ Low Pass Filter or $3 \times 3$ Gaussian filter can. What is more, I could not allowed myself to not process border pixels. Because of all of this requirements simple extension to Low Pass Filter has been made.

Kernel of size $15 \times 15$ and looks as follows:
 
\[
\left(
    \scalemath{0.5}{
    \begin{array}{ccccccccccccccc}
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
     1 & 1 & 1 & 1 & 1 & 1 &1 & 1 & 1 & 1 & 1 & 1 & 1 &1 &1\\
    \end{array}
    }
  \right)
\] 
 

with coefficient $d = \frac{1}{225 - \sigma}$, where $\sigma$ is number of pixels that can not be processed due to border case. In other words, for pixel of interest $px$, $\sigma$ represents number of $f[x,y]$ values for, which there is no corresponding $g[x,y]$ value (see equation \ref{final_two_var_conv_one_var_disc} and "Convolution Filters" subsection for a reference). 

%
% MORPHOLOGICAL IMAGE PROCESSING DEFINITION
%
\item[Morphological Image Processing] Is a collection of non-linear operations related to the shape or morphology of features in an image. According to \cite{morph_wiki}, morphological operations rely only on the relative ordering of pixel values, not on their numerical values, and therefore are especially suited to the processing of binary images.

Morphological techniques probe an image with a small shape or template called a structuring element. The structuring element is positioned at all possible locations in the image and it is compared with the corresponding neighbourhood of pixels \cite{morphological}.

%
% STRUCTING ELEMENT DEFINITION
%
\item[Structing Element] As stated in \cite{morphological}, structing element is a small binary image, i.e. a small matrix of pixels, each with a value of $0$ or $1$:

\begin{itemize}
\item The matrix dimensions specify the size of the structuring element.
\item The pattern of ones and zeros specifies the shape of the structuring element.
\item An origin of the structuring element is usually one of its pixels, although generally the origin can be outside the structuring element
\end{itemize}

Figure \ref{fig:struct_exampl} depicts squared, diamond-shaped and cross-shaped elements, respectively.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{_Figures/struct_el_example.jpg}
  \caption{Examples of structing element for morphological operations.}
  \label{fig:struct_exampl}
\end{figure}%


A common practice is to have odd dimensions of the structuring matrix and the origin defined as the centre of the matrix. Structuring elements play in morphological image processing the same role as convolution kernels in linear image filtering \cite{morphological}.

The structuring element is said to \textbf{fit} the image if, for each of its pixels set to 1, the corresponding image pixel is also 1. Similarly, a structuring element is said to \textbf{hit}, or intersect, an image if, at least for one of its pixels set to 1 the corresponding image pixel is also 1 \cite{morphological}.

\textcolor{red}{Remark:} In case of border pixels, I will follow pattern implemented in Matlab \cite{matlab}: during dilation, pixels beyond the image border are assigned the minimum value afforded by the data type (e.g in binary images, these pixels are assumed to be set to 0). On the other hand during erosion, such a pixels will take maximum value (again, for binary images binary images, these pixels are assumed to be set to 1).

%
% EROSION DEFINITION
%
\item[Erosion] We define erosion ($\ominus$) of binary image $f$ by structuring element $s$ as:
\[
    f \ominus s= (\forall{(x,y) \in f})  \;\;
    g(x,y) = 
\begin{cases}
    1,& \text{if s fits f }\\
    0,              & \text{otherwise}
\end{cases} 
\]
, where $g$ is output image and $g(x,y)$ denotes value of pixel of coordinate $(x,y)$ on $g$.

What is interesting erosion is equivalent to computing local minimum over the area of the structuring element. We scan the input image $f$, we compute minimal pixel value overlapped by $s$ and we replace pixel of interest with this value (we save it in $g$)\cite{slajdy_morph}.

Figure \ref{fig:erosion_exampl} presents erosion on small image with $3 \times 3$ squared-shaped structuring element.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\linewidth]{_Figures/erosion_example.jpg}
  \caption{Example of erosion.}
  \label{fig:erosion_exampl}
\end{figure}%

%
% DILATION DEFINITION
%
\item[Dilation] We define dilation ($\oplus$) of binary image $f$ by structuring element $s$ as:
\[
    f \oplus s= (\forall{(x,y) \in f})  \;\;
    g(x,y) = 
\begin{cases}
    1,& \text{if s hits f }\\
    0,              & \text{otherwise}
\end{cases} 
\]
, where $g$ is output image and $g(x,y)$ denotes value of pixel of coordinate $(x,y)$ on $g$.

Dilation is converse of erosion. It gradually enlarges the boundaries of regions of foreground pixels. Thus areas of foreground regions grow in size, while holes within those regions become smaller \cite{slajdy_morph}.

Figure \ref{fig:dilation_exampl} presents dilation on small image with $3 \times 3$ squared-shaped structuring element.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.4\linewidth]{_Figures/dilation_example.jpg}
  \caption{Example of dilation.}
  \label{fig:dilation_exampl}
\end{figure}%

%
% OPENING DEFINITION
% 
\item[Opening]
The opening of an image $f$  by a structuring element $s$ (denoted by $f \circ s$) is an erosion followed by a dilation \cite{morphological}: 
\[
f \circ s = (f \ominus s) \oplus s
\]
Opening is so called because it can open up a gap between objects connected by a thin bridge of pixels. Any regions that have survived the erosion are restored to their original size by the dilation.

In addition, opening is an idempotent operation: once an image has been opened, subsequent openings with the same structuring element have no further effect on that image \cite{morphological}:
\[
(f \circ s) \circ s = f \circ s
\]


%
% CLOSING DEFINITION
%
\item[Closure] The closure of an image $f$  by a structuring element $s$ (denoted by $f \bullet s$) is a dilation followed by an erosion: 
\[
f \bullet s = (f \oplus s_{rot}) \ominus s_{rot}
\]
, where $s_{rot}$ denotes structuring element rotated by $180^{o}$. In most cases $s$ will be symmetrical though.

Closure is so called because it can fill holes in the regions while keeping the initial region sizes. Like opening, closing is idempotent \cite{morphological}:
\[
(f \bullet s) \bullet s = f \bullet s
\]

\pagebreak
%
% REGION FILLING ALGORITHM DEFINITION
%

\item[Region Filling (Conditional Dilation)]
Let us assume that we have a region $A$ and its boundary $\beta (A)$. By $A^{C}$ we will mean operation of reversing values of $A$ - if some pixel of $A$ has value 1, on $A^{C}$ its value will be 0 and vice versa. We also have pixel $x = X_{0}$, which is inside $\beta (A)$. As usual we denote structuring element as $s$ and its values are:
\[
\begin{pmatrix}
  0 & 1 & 0 \\
  1 & 1 & 1 \\
  0 & 1 & 0 \\
 \end{pmatrix}
 \]


Next steps of the algorithm are defined as follows:
\[
X_{k} = (x_{k-1} \oplus s) \cap A^{C}, \; \; \; \text{for  } k = 1,2,3,\cdots
\]
, until $X_k = X_{k-1}$. Then we obtain filled region with following operation:
\[
A \cup X_k
\]

Figure \ref{fig:conditional_dilation_example} gives an example of algorithm work.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/conditional_example.jpg}
    \caption{Example of steps of Conditional Dilation algorithm.}
    \label{fig:conditional_dilation_example}
\end{figure}



\end{description} 
\pagebreak
 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Experimental Data} \label{experimental_data}
During laboratory we used only one image (i.e. \ref{fig:experimental_data_1}), but to enrich this report I will use another two of them. Since final task was to find pupil, I decided that all data will present human eyes. See figure \ref{fig:experimental_data_1}, \ref{fig:experimental_data_2}, \ref{fig:experimental_data_3}.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{_Figures/raw_data_1.jpg}\hfill
\caption{Experimental data.}
\label{fig:experimental_data_1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{_Figures/raw_data_3.jpg}\hfill
\caption{cnd. Experimental data.}
\label{fig:experimental_data_2}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{_Figures/raw_data_4.jpg}\hfill
\caption{cnd. Experimental data.}
\label{fig:experimental_data_3}
\end{figure}




%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------
\newpage
\section{Sample Code}
This section contains code snippets with algorithms implementation. Each figures is provided with appropriate description either in caption or in method's comment. 


%
% CONVOLUTION FILTER CODE
%

\subsection{Convolution Filter Implementation} \label{conv_filter_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.98\textwidth]{_Figures/code/conv_filter.jpg}
    \caption{Most important methods of ConvolutionFilter class.}
    \label{fig:code:conv_filter}
\end{figure}


\newpage
%
% HIGH PASS CODE
%
\subsection{High Pass Filter Implementation} \label{high_pass_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{_Figures/code/highpass.jpg}
    \caption{Implementation of HighPassFilter class.}
    \label{fig:code:highpass}
\end{figure}

%
% LOW PASS CODE
% 
\subsection{Low Pass Filter Implementation} \label{low_pass_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{_Figures/code/lowpass.jpg}
    \caption{Implementation of LowPassFilter class.}
    \label{fig:code:lowpass}
\end{figure}

\newpage
%
% GAUSSIAN FILTER CODE
%
\subsection{Gaussian Filter Implementation} \label{gaussian_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{_Figures/code/gaussian.jpg}
    \caption{Implementation of GaussianFilter class.}
    \label{fig:code:gaussian}
\end{figure}

%
% SOBEL FILTER
%
\subsection{Sobel Filter Implementation} \label{sobel_impl}
In this case I had to override $calculateKernel$ method, because the filter does not depend on kernel matrix in sense defined in section \ref{definitions}. Other presented methods are just auxillary 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/sobel_1.jpg}
    \caption{Methods relevant to Sobel filter implementation.}
    \label{fig:code:sobel_1}
\end{figure}

\newpage

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{_Figures/code/sobel_2.jpg}
    \caption{cnd. Methods relevant to Sobel filter implementation.}
    \label{fig:code:dobel_2}
\end{figure}

\newpage

%
% BLUR FILTER
%
\subsection{Blur Filter Implementation} \label{blur_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.82\textwidth]{_Figures/code/blur.jpg}
    \caption{Methods relevant to Blur filter implementation.}
    \label{fig:code:blur}
\end{figure}

%
% MORPHOLOGICAL OPERATION
%
\subsection{Morphological Implementation} \label{morph_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/morph_1.jpg}
    \caption{Methods relevant to MorphologicalOperation class implementation.}
    \label{fig:code:blur}
\end{figure}


\newpage


\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/morph_2.jpg}
    \caption{cnd. Methods relevant to MorphologicalOperation class implementation.}
    \label{fig:code:blur}
\end{figure}


\newpage
%
% EROSION OPERATION
%
\subsection{Erosion Implementation} \label{erosion_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/erosion.jpg}
    \caption{Methods relevant to Erosion implementation}
    \label{fig:code:erosion}
\end{figure}


%
% DILATION OPERATION
%
\subsection{Dilation Implementation} \label{dilation_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{_Figures/code/dilation.jpg}
    \caption{Methods relevant to Dilation implementation}
    \label{fig:code:dilation}
\end{figure}

\newpage
%
% CONDITIONAL DILTION 
%
\subsection{Conditional Dilation Implementation} \label{cond_dil_impl}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{_Figures/code/cond_dilation.jpg}
    \caption{Most interesting methods of Condition Dilation implementation.}
    \label{fig:code:dilation}
\end{figure}

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------
\newpage
\section{Results and Conclusions}

%
% HIGHPASS RESULTS
%

\subsection{High Pass Filter Results}
High Pass filter as described in section \ref{definitions} has been applied to each RGB channel of experimental data (section \ref{experimental_data}). Implementation of method is presented in subsection \ref{high_pass_impl}.

As one can see, original pixels with higher saturation are now emphasised.
\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1.jpg}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_highpass.png}
  \caption{}
  \label{fig:raw_1_highpass}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3.jpg}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_highpass.png}
  \caption{}
  \label{fig:raw_3_highpass}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4.jpg}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_highpass.png}
  \caption{}
  \label{fig:raw_4_highpass}
\end{subfigure}

\caption{Results of applying High Pass filter. }
\label{fig:highpass_results}
\end{figure}

%
% LOWPASS RESULTS
%
\newpage
\subsection{Low Pass Filter Results}
Low Pass filter as described in section \ref{definitions} has been applied to each RGB channel of experimental data (section \ref{experimental_data}). Implementation of method is presented in subsection \ref{low_pass_impl}.

As one can see, images are blurred a little bit.

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1.jpg}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_lowpass.png}
  \caption{}
  \label{fig:raw_1_lowpass}
\end{subfigure}



\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3.jpg}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_lowpass.png}
  \caption{}
  \label{fig:raw_3_lowpass}
\end{subfigure}




\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4.jpg}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_lowpass.png}
  \caption{}
  \label{fig:raw_4_lowpass}
\end{subfigure}

\caption{Results of applying Low Pass filter. }
\label{fig:lowhpass_results}
\end{figure}


%
% GAUSSIAN RESULTS
%
\newpage
\subsection{Gaussian Filter Results}
Gaussian filter as described in section \ref{definitions} has been applied to each RGB channel of experimental data (section \ref{experimental_data}). Implementation of method is presented in subsection \ref{gaussian_impl}.

Again, image has been blurred. Effect is not so visible because of small kernel.

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1.jpg}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_gaussian.png}
  \caption{}
  \label{fig:raw_1_gaussian}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3.jpg}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_gaussian.png}
  \caption{}
  \label{fig:raw_3_gaussian}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4.jpg}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_gaussian.png}
  \caption{}
  \label{fig:raw_4_gaussian}
\end{subfigure}

\caption{Results of applying Gaussian filter. }
\label{fig:gaussian_results}
\end{figure}

%
% SOBEL RESULTS
%
\newpage
\subsection{Sobel Filter Results}
Sobel filter as described in section \ref{definitions} has been applied to each RGB channel of experimental data (section \ref{experimental_data}). Implementation of method is presented in subsection \ref{gaussian_impl}.

In this case results are far more interesting. Sobel filter revealed edges. Figure \ref{fig:special} looks cool.


\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1.jpg}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_sobel.png}
  \caption{}
  \label{fig:raw_1_sobel}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3.jpg}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_sobel.png}
  \caption{}
  \label{fig:special}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4.jpg}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_sobel.png}
  \caption{}
  \label{fig:raw_4_sobel}
\end{subfigure}

\caption{Results of applying Sobel filter. }
\label{fig:sobel_results}
\end{figure}

%
% BLUR RESULTS
%
\newpage
\subsection{Blur Filter Results}
Blur filter as described in section \ref{definitions} has been applied to each RGB channel of experimental data (section \ref{experimental_data}). Implementation of method is presented in subsection \ref{blur_impl}

In this case results are far more interesting. Images has been more blurred than in case of Gaussian/Low Pass filter. 

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1.jpg}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_blur.png}
  \caption{}
  \label{fig:raw_1_blur}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3.jpg}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_blur.png}
  \caption{}
  \label{fig:raw_3_blur}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4.jpg}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_blur.png}
  \caption{}
  \label{fig:raw_4_blur}
\end{subfigure}

\caption{Results of applying Blur filter. }
\label{fig:blur_results}
\end{figure}

%
% EROSION RESULTS
%
\newpage
\subsection{Erosion Operation Results} \label{erosion_results}
\textcolor{red}{Remark:} to the end of this section as an input image we will use binarized experimental data. Binarization is done via applying grayscale filter followed by tresholding at level 10. In addition default structuring element will be used to perform morphological operations:
\[
\begin{pmatrix}
  1 & 1 & 1 \\
  1 & 1 & 1 \\
  1 & 1 & 1  \\
 \end{pmatrix}
 \]
 
To elevate visibility of the operation, erosion has been applied 3 times.

In this case results are far more interesting. It is easily observable that white regions are starting to bulge.

\begin{figure}[H]
\centering
\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_binary.png}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_erosion.png}
  \caption{}
  \label{fig:raw_1_erosion}
\end{subfigure}

\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_binary.png}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_erosion.png}
  \caption{}
  \label{fig:raw_3_erosion}
\end{subfigure}


\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_binary.png}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.37\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_erosion.png}
  \caption{}
  \label{fig:raw_4_erosion}
\end{subfigure}

\caption{Results of applying Erosion operation. }
\label{fig:erosion_results}
\end{figure}

%
% DILATION RESULTS
%
\newpage
\subsection{Dilation Operation Results}
See remark in section \ref{erosion_results} for information about input image and structuring element settings.
 
To elevate visibility of the operation, erosion has been applied 3 times.

In this case results are far more interesting. One can observe that regions are vanishing and shrinking.

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_binary.png}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_dilation.png}
  \caption{}
  \label{fig:raw_1_dilation}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_binary.png}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_dilation.png}
  \caption{}
  \label{fig:raw_3_dilation}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_binary.png}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_dilation.png}
  \caption{}
  \label{fig:raw_4_dilation}
\end{subfigure}

\caption{Results of applying Dilation operation. }
\label{fig:dilation_results}
\end{figure}


%
% OPENING RESULTS
%
\newpage
\subsection{Opening Operation Results}
See remark in section \ref{erosion_results} for information about input image and structuring element settings.

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_binary.png}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_opening.png}
  \caption{}
  \label{fig:raw_1_opening}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_binary.png}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_opening.png}
  \caption{}
  \label{fig:raw_3_opening}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_binary.png}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_opening.png}
  \caption{}
  \label{fig:raw_4_opening}
\end{subfigure}

\caption{Results of applying Opening operation. }
\label{fig:opening_results}
\end{figure}



%
% CLOSURE RESULTS
%
\newpage
\subsection{Closure Operation Results}
See remark in section \ref{erosion_results} for information about input image and structuring element settings.

\begin{figure}[H]
\centering
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_binary.png}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_closure.png}
  \caption{}
  \label{fig:raw_1_closure}
\end{subfigure}

\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_binary.png}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_closure.png}
  \caption{}
  \label{fig:raw_3_closure}
\end{subfigure}


\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_binary.png}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.47\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_closure.png}
  \caption{}
  \label{fig:raw_4_closure}
\end{subfigure}

\caption{Results of applying Closure operation. }
\label{fig:closure_results}
\end{figure}


%
% CONDITIONAL DILATION RESULTS
%
\newpage
\subsection{Conditional Dilation Results}
See remark in section \ref{erosion_results} for information about input image and structuring element settings. In addition I have used Sobel filter on input images to extract edges. All images has been seeded (with regard to conditional dilation) in upper right corner. Simply I have assumed that pupil will never be in this place of an image.

As one can see conditional dilation works very well. Only drawback of this method is \textcolor{red}{long computation time}. There is no way to do this online. Another option would be filling region of pupil instead of background but it may happen that pupil region has some weird internal structure e.g. full of smaller regions. In such a case not whole pupil region would be extracted.

\begin{figure}[H]
\centering
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_sobel_algo.png}
  \caption{}
  \label{fig:raw_1}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_1_cond_dilation.png}
  \caption{}
  \label{fig:raw_1_closure}
\end{subfigure}

\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_sobel_algo.png}
  \caption{}
  \label{fig:raw_3}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_3_cond_dilation.png}
  \caption{}
  \label{fig:raw_3_closure}
\end{subfigure}


\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_sobel_algo.png}
  \caption{}
  \label{fig:raw_4}
\end{subfigure}%
\begin{subfigure}{.09\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/leftrightarrow.jpg}
  \label{fig:arrow}
\end{subfigure}%
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=0.97\linewidth]{_Figures/raw_data_4_cond_dilation.png}
  \caption{}
  \label{fig:raw_4_closure}
\end{subfigure}

\caption{Results of applying Conditional Dilation. }
\label{fig:closure_results}
\end{figure}




%
% PUPIL EXTRACTION RESULTS
%
\newpage
\subsection{Pupil Extraction Results}
Consecutive steps of my algorithm has been depicted on figure \ref{fig:algo_flow}. At the $Features extraction$ phase, diameter and pupil center have been extracted. A way to do this is finding longest, horizontal black line on an image. Line itself is diameter and center of the pupil its center of diameter. Results have been saved on original image for clarity; figures \ref{fig:results_1}, \ref{fig:results_2}, \ref{fig:results_3}. Red line indicates diameter and white dot its centre of pupil.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{_Figures/algorithm_flow.jpg}
  \caption{Pupil diameter/center extraction algorithm flow.}
  \label{fig:algo_flow}
\end{figure}%

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{_Figures/raw_data_1_algo_results.png}\hfill
\caption{Pupil diameter and center extraction from experimental data.}
\label{fig:results_1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{_Figures/raw_data_3_algo_results.png}\hfill
\caption{Pupil diameter and center extraction from experimental data.}
\label{fig:results_2}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{_Figures/raw_data_4_algo_results.png}\hfill
\caption{Pupil diameter and center extraction from experimental data.}
\label{fig:results_3}
\end{figure}

\newpage
\subsection{Conclusions}
In my opinion results of the pupil extraction algorithm are quite satisfying. In all three cases pupil has been localized correctly. Diameters and centers also seems all right. Only drawback of presented method is time needed to compute Conditional Dilation. This problem can be workaround using e.g. flood fill algorithm, which is much faster. There is sadly no recipe, which comes into my mind, fo making this approach work in real-time.

As for other filters, thoughts has been shared during presenting results for each one of them.

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\begin{thebibliography}{1}
	\bibitem{convolution_wolphram} \url{http://mathworld.wolfram.com/Convolution.html}
	\bibitem{convolution_wiki} \url{https://en.wikipedia.org/wiki/Convolution}
	\bibitem{convolution_equations} \url{https://graphics.stanford.edu/courses/cs178/applets/convolution.html}
	\bibitem{high_pass_def} \url{http://northstar-www.dartmouth.edu/doc/idl/html_6.2/Filtering_an_Imagehvr.html}
	\bibitem{gaussian_blur} \url{https://en.wikipedia.org/wiki/Gaussian_blur}
	\bibitem{sobel_bib1} \url{http://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm}
	\bibitem{morph_wiki} \url{https://en.wikipedia.org/wiki/Mathematical_morphology}	
	\bibitem{morphological} \url{https://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/ImageProcessing-html/topic4.htm}		
	\bibitem{matlab} \url{http://www.mathworks.com/help/images/morphology-fundamentals-dilation-and-erosion.html}
	\bibitem{slajdy_morph} \url{http://www.slideshare.net/vinayaknarayanan/morphological-image-processing-12323183}
	
\end{thebibliography}

%----------------------------------------------------------------------------------------


\end{document}